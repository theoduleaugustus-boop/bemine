<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Valentine üíò</title>
  <style>
    :root{
      --pink:#ff4fa3;
      --pink2:#ff77b7;
      --rose:#ff2d55;
      --soft:#fff1f7;
      --card:#ffffffcc;
      --text:#2a1630;
      --muted:#6b3a5a;
      --yes1:#ff4fa3;
      --yes2:#ff77b7;
      --no1:#ff6b8a;
      --no2:#ff9fb5;
      --shadow: 0 18px 50px rgba(255,79,163,.22);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 600px at 10% 10%, #ffd1e866, transparent 55%),
        radial-gradient(900px 600px at 90% 30%, #ffb4d466, transparent 60%),
        linear-gradient(180deg, #fff6fb, #ffe7f3);
      overflow:hidden;
    }

    /* soft vignette */
    body::after{
      content:"";
      position:fixed; inset:0;
      background: radial-gradient(1200px 700px at 50% 35%, transparent 55%, rgba(255,45,85,.08) 100%);
      pointer-events:none;
    }

    /* Floating hearts layer container */
    .bg{
      position:fixed; inset:0;
      overflow:hidden;
      pointer-events:none;
      z-index:0;
    }

    .wrap{
      position:relative;
      height:100%;
      display:grid;
      place-items:center;
      padding:18px;
      z-index:1;
    }

    .card{
      width:min(640px, 100%);
      background:var(--card);
      border:1px solid rgba(255,79,163,.20);
      border-radius:26px;
      padding:22px 18px;
      box-shadow: var(--shadow);
      text-align:center;
      backdrop-filter: blur(10px);
      position:relative;
      overflow:hidden;
    }

    .ribbon{
      position:absolute;
      inset:auto -30px -30px auto;
      width:180px; height:180px;
      background: radial-gradient(circle, rgba(255,79,163,.18), transparent 60%);
      transform: rotate(20deg);
    }

    h1{
      margin:6px 0 6px;
      font-size: clamp(22px, 4.6vw, 36px);
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0 0 16px;
      color:var(--muted);
      font-size: clamp(14px, 2.6vw, 16px);
      line-height:1.35;
    }

    /* Cute vinyl */
    .vinyl-wrap{
      display:flex;
      justify-content:center;
      margin:8px 0 12px;
    }
    .vinyl{
      width:130px; height:130px;
      border-radius:50%;
      background:
        radial-gradient(circle at 50% 50%, #ffffff 0 9px, transparent 10px),
        radial-gradient(circle at 50% 50%, #ffd1e8 0 28px, #ff8fc6 29px 100%),
        repeating-radial-gradient(circle at 50% 50%, rgba(255,255,255,.0) 0 3px, rgba(255,255,255,.22) 3px 6px);
      box-shadow: 0 12px 28px rgba(255,79,163,.22);
      position:relative;
      animation: spin 2.6s linear infinite;
    }
    .vinyl::after{
      content:"";
      position:absolute;
      inset:18px;
      border-radius:50%;
      background:
        radial-gradient(circle, #ffffff 0 18px, #ff4fa3 19px 60%, #ffb703 61% 100%);
      opacity:.85;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .btn-zone{
      position:relative;
      width:min(520px, 100%);
      height:190px;
      margin:0 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:16px;
    }

    button{
      border:0;
      padding:14px 18px;
      border-radius:16px;
      font-size:16px;
      font-weight:800;
      cursor:pointer;
      transition: transform .12s ease, filter .18s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 14px 28px rgba(255,79,163,.18);
    }
    button:active{ transform: scale(.98); }

    #yesBtn{
      background: linear-gradient(135deg, var(--yes1), var(--yes2));
      color:#fff;
    }
    #yesBtn:hover{ filter: brightness(1.03); }

    /* No button: we animate its transform smoothly */
    #noBtn{
      position:absolute;
      left: 66%;
      top: 56%;
      background: linear-gradient(135deg, var(--no1), var(--no2));
      color:#5b1630;
      box-shadow: 0 14px 28px rgba(255,107,138,.22);
      will-change: transform;
    }
    #noBtn:hover{ filter: brightness(1.02); }

    .hint{
      margin-top:8px;
      font-size:12px;
      color: rgba(107,58,90,.78);
    }

    /* Dialog bubble for "No" catches */
    .toast{
      position:absolute;
      left:50%;
      top:10px;
      transform: translateX(-50%);
      background: rgba(255,255,255,.86);
      border: 1px solid rgba(255,79,163,.18);
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 700;
      font-size: 14px;
      color: #6b2c53;
      box-shadow: 0 14px 30px rgba(255,79,163,.18);
      opacity:0;
      pointer-events:none;
      transition: opacity .25s ease, transform .25s ease;
      z-index:5;
      white-space:nowrap;
      max-width: calc(100% - 24px);
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(4px);
    }

    /* Success overlay */
    .overlay{
      position:fixed; inset:0;
      display:none;
      place-items:center;
      background: rgba(255,246,251,.9);
      backdrop-filter: blur(8px);
      z-index:999;
      padding:18px;
    }
    .overlay.show{ display:grid; }

    .success{
      width:min(700px, 100%);
      border:1px solid rgba(255,79,163,.22);
      border-radius:26px;
      background:#ffffffd8;
      box-shadow: 0 25px 80px rgba(255,79,163,.25);
      padding:22px 18px;
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .success h2{
      margin:8px 0 6px;
      font-size: clamp(26px, 5vw, 44px);
    }
    .success p{
      margin:0 0 16px;
      color: rgba(107,58,90,.9);
    }

    .actions{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      justify-content:center;
      margin-top:8px;
    }

    .btn2{
      background: linear-gradient(135deg, #60a5fa, #a78bfa);
      color:#09101f;
      font-weight:900;
    }
    .btn3{
      background: linear-gradient(135deg, #34d399, #a7f3d0);
      color:#062015;
      font-weight:900;
    }

    /* Confetti */
    .confetti{
      position:fixed;
      width:10px; height:16px;
      top:-20px;
      border-radius:4px;
      opacity:.95;
      pointer-events:none;
      animation: confFall linear forwards;
      z-index:1000;
    }
    @keyframes confFall{
      to{ transform: translateY(120vh) rotate(720deg); opacity:0.95; }
    }

    /* Heart particles */
    .float-heart{
      position:absolute;
      left:0; top:0;
      font-size:18px;
      opacity:.9;
      filter: drop-shadow(0 10px 14px rgba(255,79,163,.18));
      animation: rise linear forwards;
    }
    @keyframes rise{
      from{ transform: translate(var(--x), 110vh) scale(var(--s)); opacity:0; }
      10%{ opacity:.95; }
      to{ transform: translate(calc(var(--x) + var(--drift)), -15vh) scale(calc(var(--s) + .15)); opacity:0; }
    }

    /* little sparkle hearts that appear on interactions */
    .pop{
      position:fixed;
      font-size:18px;
      pointer-events:none;
      opacity:.95;
      animation: popUp .9s ease forwards;
      filter: drop-shadow(0 10px 14px rgba(255,79,163,.18));
      z-index:50;
    }
    @keyframes popUp{
      from{ transform: translateY(0) scale(.9); opacity:0; }
      20%{ opacity:1; }
      to{ transform: translateY(-60px) scale(1.12); opacity:0; }
    }

    @media (max-width:420px){
      button{ width:140px; }
      .btn-zone{ height:210px; }
    }
  </style>
</head>

<body>
  <div class="bg" id="bg"></div>

  <div class="wrap">
    <div class="card">
      <div class="ribbon" aria-hidden="true"></div>
      <div class="toast" id="toast">üôÇ</div>

      <div class="vinyl-wrap">
        <div class="vinyl" aria-hidden="true"></div>
      </div>

      <h1>To the love of my life Sherkima üíó</h1>
      <p class="subtitle">
        I have one important question‚Ä¶ and you‚Äôre not allowed to escape it üòå
      </p>

      <div class="btn-zone" id="btnZone">
        <button id="yesBtn">Yes ‚úÖ</button>
        <button id="noBtn">No ‚ùå</button>
      </div>

      <div class="hint">Try ‚ÄúNo‚Äù if you want‚Ä¶ it‚Äôs cute either way. üíò</div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="success">
      <h2>You said YESSS üíñ</h2>
      <p>
        I‚Äôm claiming you as my Valentine. No refunds. No returns. Only love. üòåüåπ
      </p>
      <div class="actions">
        <button class="btn3" id="playBtn">Play me ‚ñ∂Ô∏è</button>
        <button class="btn2" id="replayBtn">Replay üîÅ</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Elements
    const bg = document.getElementById("bg");
    const noBtn = document.getElementById("noBtn");
    const yesBtn = document.getElementById("yesBtn");
    const btnZone = document.getElementById("btnZone");
    const overlay = document.getElementById("overlay");
    const replayBtn = document.getElementById("replayBtn");
    const playBtn = document.getElementById("playBtn");
    const toast = document.getElementById("toast");

    // ===== Utilities
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

    function zoneRect(){ return btnZone.getBoundingClientRect(); }

    // Smooth movement state (no choppy teleport)
    let noPos = { x: 0, y: 0 };
    let target = { x: 0, y: 0 };
    let animing = false;

    function setTarget(x,y){
      const zr = zoneRect();
      const bw = noBtn.offsetWidth;
      const bh = noBtn.offsetHeight;

      const minX = 10;
      const minY = 10;
      const maxX = zr.width - bw - 10;
      const maxY = zr.height - bh - 10;

      target.x = clamp(x, minX, maxX);
      target.y = clamp(y, minY, maxY);

      if (!animing) smoothStep();
    }

    function smoothStep(){
      animing = true;

      // ease toward target
      const ease = 0.18; // smaller = slower/smoother
      noPos.x += (target.x - noPos.x) * ease;
      noPos.y += (target.y - noPos.y) * ease;

      // apply
      noBtn.style.left = noPos.x + "px";
      noBtn.style.top  = noPos.y + "px";

      // stop when close
      const dx = target.x - noPos.x;
      const dy = target.y - noPos.y;
      if (Math.hypot(dx,dy) < 0.6){
        noPos.x = target.x;
        noPos.y = target.y;
        noBtn.style.left = noPos.x + "px";
        noBtn.style.top  = noPos.y + "px";
        animing = false;
        return;
      }
      requestAnimationFrame(smoothStep);
    }

    function initNo(){
      const zr = zoneRect();
      const startX = zr.width * 0.66;
      const startY = zr.height * 0.55;
      noPos = { x: startX, y: startY };
      target = { x: startX, y: startY };
      noBtn.style.left = startX + "px";
      noBtn.style.top  = startY + "px";
    }

    // ===== Cute background hearts (more variety)
    const heartGlyphs = ["üíó","üíñ","üíò","üíï","üíû","‚ù§Ô∏è","ü©∑"];
    function spawnBgHeart(){
      const el = document.createElement("div");
      el.className = "float-heart";
      el.textContent = heartGlyphs[Math.floor(Math.random()*heartGlyphs.length)];

      const x = Math.random()*100;                // vw
      const s = 0.7 + Math.random()*0.9;          // scale
      const drift = (-30 + Math.random()*60) + "vw";
      const dur = 7 + Math.random()*7;            // seconds

      el.style.setProperty("--x", x + "vw");
      el.style.setProperty("--s", s.toFixed(2));
      el.style.setProperty("--drift", drift);
      el.style.animationDuration = dur + "s";

      bg.appendChild(el);
      setTimeout(() => el.remove(), dur*1000);
    }

    // Start a steady stream of hearts
    setInterval(() => {
      if (overlay.classList.contains("show")) return;
      // spawn 1-2 each tick for a richer background
      spawnBgHeart();
      if (Math.random() < 0.35) spawnBgHeart();
    }, 520);

    // ===== Pop heart on interactions
    function popAt(x,y){
      const el = document.createElement("div");
      el.className = "pop";
      el.textContent = heartGlyphs[Math.floor(Math.random()*heartGlyphs.length)];
      el.style.left = (x + (Math.random()*16-8)) + "px";
      el.style.top  = (y + (Math.random()*16-8)) + "px";
      document.body.appendChild(el);
      setTimeout(()=>el.remove(), 950);
    }

    // ===== Confetti
    function burstConfetti(){
      const count = 120;
      for (let i=0;i<count;i++){
        const c = document.createElement("div");
        c.className = "confetti";
        c.style.left = (Math.random()*window.innerWidth) + "px";
        c.style.animationDuration = (3 + Math.random()*2.5) + "s";
        c.style.background = `hsl(${Math.random()*360}, 90%, 60%)`;
        document.body.appendChild(c);
        setTimeout(()=>c.remove(), 6500);
      }
    }

    // ===== "No" logic:
    // - It moves away when close, but slower and smoother.
    // - Small chance she can "catch" it (click succeeds).
    // - Clicking "No" triggers cute messages (never rejects).
    let canBeCaught = false;
    let catchWindowTimer = null;

    const noMessages = [
      "Nice try üòåüíó",
      "You‚Äôre really gonna press NO? üòÇ",
      "That button is just for decoration, babe üíò",
      "Mhm‚Ä¶ you want me that bad huh üòè",
      "Okay okay I see you trying üò≠üíï",
      "Still my Valentine though üåπ",
      "You‚Äôre adorable. Keep trying üòåüíñ"
    ];

    function showToast(text){
      toast.textContent = text;
      toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> toast.classList.remove("show"), 1200);
    }

    function openCatchWindow(){
      // brief moment where click can land (so it feels catchable)
      canBeCaught = true;
      clearTimeout(catchWindowTimer);
      catchWindowTimer = setTimeout(()=> { canBeCaught = false; }, 220); // 0.22s window
    }

    function evade(pointerX, pointerY){
      const zr = zoneRect();
      const bw = noBtn.offsetWidth;
      const bh = noBtn.offsetHeight;

      // pointer relative to zone
      const px = pointerX - zr.left;
      const py = pointerY - zr.top;

      // choose a new target that isn't too far (so it looks smooth and catchable)
      const maxJump = 160; // limit jump distance to avoid "teleport feel"
      let rx = px + (Math.random()*2-1)*maxJump;
      let ry = py + (Math.random()*2-1)*maxJump;

      // also bias away from the pointer (push vector)
      const vx = (noPos.x - px);
      const vy = (noPos.y - py);
      const len = Math.hypot(vx,vy) || 1;
      rx += (vx/len) * 70;
      ry += (vy/len) * 70;

      setTarget(rx, ry);

      // sometimes allow catch chance right after it moves
      if (Math.random() < 0.22) openCatchWindow(); // 22% chance per evade
    }

    // Mouse proximity detection (gentler range)
    document.addEventListener("mousemove", (e) => {
      if (overlay.classList.contains("show")) return;
      const r = noBtn.getBoundingClientRect();
      const mx = e.clientX, my = e.clientY;
      const dist = Math.hypot((r.left + r.width/2) - mx, (r.top + r.height/2) - my);

      if (dist < 95){
        // Smooth evade, not instant
        evade(mx, my);
        popAt(mx, my);
      }
    }, { passive:true });

    // Touch support: if finger comes near, move
    btnZone.addEventListener("touchmove", (e) => {
      if (overlay.classList.contains("show")) return;
      const t = e.touches && e.touches[0];
      if (!t) return;
      evade(t.clientX, t.clientY);
    }, { passive:true });

    // Clicking "No"
    noBtn.addEventListener("click", (e) => {
      const x = e.clientX || (e.touches && e.touches[0]?.clientX) || (window.innerWidth/2);
      const y = e.clientY || (e.touches && e.touches[0]?.clientY) || (window.innerHeight/2);
      popAt(x,y);

      // If not in catch window, it slips away and shows a message
      if (!canBeCaught){
        showToast("Almost üò≠üíû");
        evade(x,y);
        return;
      }

      // If caught: show a cute line, then still keep it playful
      const msg = noMessages[Math.floor(Math.random()*noMessages.length)];
      showToast(msg);
      canBeCaught = false;

      // After being caught, move a little (so it doesn't stay easy)
      setTimeout(()=> evade(x,y), 120);
    });

    // ===== Yes flow
    yesBtn.addEventListener("click", (e) => {
      const x = e.clientX || (window.innerWidth/2);
      const y = e.clientY || (window.innerHeight/2);
      popAt(x,y);

      overlay.classList.add("show");
      burstConfetti();
    });

    replayBtn.addEventListener("click", () => {
      overlay.classList.remove("show");
    });

    // ===== "Play me" (built-in tiny melody using Web Audio)
    let audioCtx = null;
    function playLoveMelody(){
      try{
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const ctx = audioCtx;

        const notes = [523.25, 587.33, 659.25, 783.99, 659.25, 587.33, 523.25]; // C5 D5 E5 G5 E5 D5 C5
        const now = ctx.currentTime;

        notes.forEach((freq, i) => {
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = "sine";
          o.frequency.value = freq;

          g.gain.setValueAtTime(0.0001, now + i*0.18);
          g.gain.exponentialRampToValueAtTime(0.18, now + i*0.18 + 0.03);
          g.gain.exponentialRampToValueAtTime(0.0001, now + i*0.18 + 0.16);

          o.connect(g);
          g.connect(ctx.destination);

          o.start(now + i*0.18);
          o.stop(now + i*0.18 + 0.18);
        });
      } catch (err){
        // If audio blocked, just ignore
      }
    }

    playBtn.addEventListener("click", () => {
      playLoveMelody();
      showToast("Playing üòåüé∂");
    });

    // ===== Init / keep button inside on resize
    window.addEventListener("load", () => initNo());
    window.addEventListener("resize", () => initNo());
  </script>
</body>
</html>
